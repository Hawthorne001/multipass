name: Whitespace
description: Run Whitespace steps

inputs:
  exclude:
    description: 'Multiple strings parameter'
    required: false
    type: string

runs:
  using: composite
  steps:
    - name: Derive excluded pathspecs
      shell: bash
      id: derive-exclusions
      run: |
        set -e -o pipefail

        # using ":!<path>" for exclusion pathspecs. Look for pathspec in `man gitglossary` for more
        exclusions=""
        for entry in ${{ inputs.exclude }}; do
          echo "Excluding path: $entry"
          exclusions+="':!$entry' "
        done

        echo "exclusion_pathspecs=$exclusions" >> $GITHUB_OUTPUT

    - name: Check for bad whitespace changes
      shell: bash
      run: |
        set -e -o pipefail

        echo "DEBUG: Exclusion pathspecs: ${{ steps.derive-exclusions.outputs.exclusion_pathspecs }}" # TODO remove

        # On pull requests, HEAD^1 will always be the merge base
        git diff --check HEAD^1                         \
          ':!3rd-party/'     `# third-party submodules` \
          ':!data/'          `# data files`             \
          ':!docs/.sphinx/'  `# vendored`

    - name: Check for missing newline at EOF
      shell: bash
      run: |
        set -e -o pipefail

        BAD_ENDING='(?:\n\n|[^\n])\z' # multiple or no newline at EOF

        # using ":!<path>" for excluding pathspecs. Look for pathspec in `man gitglossary` for more
        git grep --no-color -Ilz '' --      `# list text files in the repo; pathspecs follow` \
          ':!3rd-party/'                    `# third-party submodules`                        \
          ':!data/'                         `# data files`                                    \
          ':!docs/.sphinx/'                 `# vendored starter pack`                         \
          | xargs -0 grep -lzP "$BAD_ENDING" # grep their full contents for bad endings

        if [ $? -eq 0 ]; then
          echo "##[error] Files above end with multiple or no newline at all"
          exit 1
        fi
