name: WindowsMacOS

on:
  push:
    branches:
    - full
    - release/[0-9]+.[0-9]+
    tags:
    - v[0-9]+.[0-9]+.[0-9]+\+full
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  repository_dispatch:
    types: [public_build]
  workflow_dispatch:

env:
  HEAD_REF: ci${{ github.run_id }}
  RUN_URL: "${{ github.event.repository.html_url }}/actions/runs/${{ github.run_id }}"

jobs:
  # This job is here so that the Windows and macOS builds share exactly the same
  # git tree (including the merge of public), and as a result have the same version
  # numbers.
  Checkout:
    runs-on: ubuntu-latest

    steps:
    - name: Check out code
      uses: actions/checkout@v2
      with:
        # Need to check it all out to merge successfully.
        fetch-depth: 0

    - name: Fetch the dispatching ref
      if: ${{ github.event_name == 'repository_dispatch' }}
      run: |
        # Try and fetch the matching branch.
        if [ -n "${{ github.event.client_payload.head_ref }}" ] && git fetch origin ${{ github.event.client_payload.head_ref }}; then
          echo "::set-output name=ref::${{ github.event.client_payload.head_ref }}"
        else
          # Otherwise fetch the triggering commit.
          git -c protocol.version=2 fetch --prune --progress --no-recurse-submodules ${{ github.event.client_payload.repositoryUrl }} ${{ github.event.client_payload.sha }}
          echo "::set-output name=ref::${{ github.event.client_payload.ref }}"
        fi

    - name: Merge the dispatching ref
      if: ${{ github.event_name == 'repository_dispatch' }}
      run: |
        git config user.name "Multipass CI Bot"
        git config user.email "multipass-ci-bot@canonical.com"
        git merge FETCH_HEAD -m "Automatic merge of ${{ github.event.client_payload.ref }}@$( git rev-parse --short FETCH_HEAD )"

    - name: Create the branch
      run: git branch ${{ env.HEAD_REF }}

    - name: Remove authentication
      run: git config --local http.https://github.com/.extraheader ""

    - name: Upload the repository
      uses: actions/upload-artifact@v2
      with:
        name: ${{ env.HEAD_REF }}.git
        path: .git/**
        if-no-files-found: error

  Lint:
    needs: Checkout
    runs-on: ubuntu-latest

    if: ${{ github.event_name != 'push' }}

    steps:
    - name: Retrieve the repository
      uses: actions/download-artifact@v2
      with:
        name: ${{ env.HEAD_REF }}.git
        path: .git

    - name: Check out the code
      run: |
        git checkout --progress --force ${{ env.HEAD_REF }}

    - name: Run clang-format through the diff
      uses: ./.github/actions/lint

  macOS:
    needs: [Checkout, Lint]
    # Need to explicitly continue on Lint getting skipped.
    if: ${{ !failure() && needs.Checkout.result == 'success' }}

    runs-on: multipass-macos-10.14

    env:
      BUILD_DIR: ../build
      MACOSX_DEPLOYMENT_TARGET: "10.12"
      OPAM_COMP: "4.11.1"
      OPAMVERBOSE: 1
      OPAMYES: 1
      HOMEBREW_NO_AUTO_UPDATE: 1
      QT_VERSION: "5.12.10"

    steps:
    - name: Create an App token
      id: app-token
      if: ${{ github.event_name == 'repository_dispatch' }}
      uses: tibdex/github-app-token@v1
      with:
        app_id: ${{ secrets.APP_ID }}
        private_key: ${{ secrets.APP_PRIVATE_KEY }}
        repository: ${{ github.event.client_payload.repository }}

    - name: Create a check on public
      id: public-check
      if: ${{ github.event_name == 'repository_dispatch' }}
      uses: LouisBrunner/checks-action@v1.1.1
      with:
        token: ${{ steps.app-token.outputs.token }}
        repo: ${{ github.event.client_payload.repository }}
        sha: ${{ github.event.client_payload.head_sha }}
        name: ${{ github.job }}
        status: in_progress
        details_url: ${{ env.RUN_URL }}

    - name: Retrieve the repository
      uses: actions/download-artifact@v2
      with:
        name: ${{ env.HEAD_REF }}.git
        path: .git

    - name: Check out the code
      # This can't be easily abstracted into our `checkout` action due to a chicken'n'egg problem:
      # GitHub reads ./* actions from $PWD, so it needs to be checked out. It could be extracted
      # into an external repository, but that would bring its own set of issues.
      run: |
        # Authenticate with the new token.
        git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $( echo -n x-access-token:${{ secrets.GITHUB_TOKEN }} | base64 )"
        git checkout --progress --force ${{ env.HEAD_REF }}

    - name: Check out submodules and fetch tags
      uses: ./.github/actions/checkout

    - name: Determine build parameters
      id: build-params
      uses: ./.github/actions/build-params

    - name: Determine cache parameters
      id: cache-params
      run: |
        echo "::set-output name=hyperkit-sha::$( git -C 3rd-party/hyperkit rev-parse HEAD )"

    - name: Install dependencies from brew
      run: |
        brew install \
          cmake \
          coreutils \
          git \
          libev \
          libffi \
          ninja \
          openssl@1.1 \
          pkg-config \
          wget

    - name: Install Qt
      uses: jurplel/install-qt-action@v2
      with:
        mirror: http://mirrors.ocf.berkeley.edu/qt/
        setup-python: false
        version: ${{ env.QT_VERSION }}
      timeout-minutes: 10

    - name: Cache OPAM
      uses: actions/cache@v2
      with:
        path: "~/.opam"
        # Use OPAM version and hyperkit sha as cache key. This ensures that when we change hyperkit,
        # any dependency changes will follow. Also start from scratch if OPAM version changes.
        key: opam-${{ env.OPAM_COMP }}-${{ runner.os }}-${{ steps.cache-params.outputs.hyperkit-sha }}
        restore-keys: opam-${{ env.OPAM_COMP }}-${{ runner.os }}-

    - name: Set up OCaml
      uses: avsm/setup-ocaml@v1
      with:
        ocaml-version: ${{ env.OPAM_COMP }}

    - name: Set up OPAM environment
      id: opam-setup
      run: |
        for var in OPAM_SWITCH_PREFIX CAML_LD_LIBRARY_PATH OCAML_TOPLEVEL_PATH; do
            opam exec -- bash -c "echo ${var}=\${${var}}" >> ${GITHUB_ENV}
        done
        opam exec -- bash -c "echo \${OPAM_SWITCH_PREFIX}/bin" >> ${GITHUB_PATH}

    - name: Install OPAM dependencies
      run: |
        opam pin uri 3.1.0
        opam pin uri-sexp 3.1.0
        opam install 3rd-party/hyperkit --deps-only
        opam list

    - name: Set up CCache
      id: setup-ccache
      run: |
        brew install ccache
        ccache --max-size=2G

        # Find common base between full and HEAD to use as cache key.
        git -c protocol.version=2 fetch --no-tags --prune --progress --no-recurse-submodules origin full
        echo "::set-output name=key::$( git merge-base origin/full ${{ github.sha }} )"

    - name: CCache
      uses: actions/cache@v2
      with:
        key: ccache-${{ runner.os }}-${{ steps.setup-ccache.outputs.key }}
        restore-keys: |
          ccache-${{ runner.os }}-
        path: ~/.ccache

    - name: Build
      uses: lukka/run-cmake@v2
      with:
        cmakeListsOrSettingsJson: CMakeListsTxtAdvanced
        cmakeBuildType: RelWithDebInfo
        buildDirectory: ${{ env.BUILD_DIR }}
        cmakeAppendedArgs:
          -GNinja
          -DCMAKE_PREFIX_PATH=${{ env.Qt5_Dir }}
          -DMULTIPASS_UPSTREAM=origin
          -DMULTIPASS_BUILD_LABEL=${{ steps.build-params.outputs.label }}
          -DCMAKE_C_COMPILER_LAUNCHER=ccache
          -DCMAKE_CXX_COMPILER_LAUNCHER=ccache

    - name: Clear CCache stats
      run: ccache --show-stats --zero-stats

    - name: Test
      working-directory: ${{ env.BUILD_DIR }}
      run: |
        bin/multipass_tests

    - name: Package
      id: cmake-package
      working-directory: ${{ env.BUILD_DIR }}
      run: |
        cmake --build . --target package
        echo "::set-output name=name::$( basename *.pkg )"
        echo "::set-output name=path::$( greadlink -f *.pkg )"

    - name: Get CPack logs
      if: ${{ failure() && steps.cmake-package.outcome == 'failure' }}
      run: cat ${{ env.BUILD_DIR }}/_CPack_Packages/Darwin/productbuild/InstallOutput.log

    - name: Upload package
      uses: actions/upload-artifact@v2
      with:
        name: ${{ steps.cmake-package.outputs.name }}
        path: ${{ steps.cmake-package.outputs.path }}
        if-no-files-found: error

    - name: Create an App token
      # The token in app-token expires after an hour, and a full macOS build
      # (including bors and ocaml setup) may take more than that, so need to
      # get a new one. This would probably be better integrated into the check
      # action itself.
      id: app-token-update
      if: ${{ always() && github.event_name == 'repository_dispatch' }}
      uses: tibdex/github-app-token@v1
      with:
        app_id: ${{ secrets.APP_ID }}
        private_key: ${{ secrets.APP_PRIVATE_KEY }}
        repository: ${{ github.event.client_payload.repository }}

    - name: Update the check on public
      if: ${{ always() && github.event_name == 'repository_dispatch' }}
      uses: LouisBrunner/checks-action@v1.1.1
      with:
        token: ${{ steps.app-token-update.outputs.token }}
        repo: ${{ github.event.client_payload.repository }}
        sha: ${{ github.event.client_payload.head_sha }}
        check_id: ${{ steps.public-check.outputs.check_id }}
        conclusion: ${{ job.status }}

    - name: Cleanup
      if: ${{ always() }}
      run: |
        rm -Rf $( find . -mindepth 1 -maxdepth 1 )  # to remove hidden things, too
        rm -Rf ${{ env.BUILD_DIR }}
        rm -Rf ${{ runner.workspace }}/Qt
        rm -Rf ~/.opam

  Windows:
    needs: [Checkout, Lint]
    # Need to explicitly continue on Lint getting skipped.
    if: ${{ !github.event.pull_request.draft && github.event.client_payload.draft != 'true' && !failure() && needs.Checkout.result == 'success' }}

    runs-on: windows-latest

    env:
      BUILD_DIR: ../build

    steps:
    - name: Create an App token
      id: app-token
      if: ${{ github.event_name == 'repository_dispatch' }}
      uses: tibdex/github-app-token@v1
      with:
        app_id: ${{ secrets.APP_ID }}
        private_key: ${{ secrets.APP_PRIVATE_KEY }}
        repository: ${{ github.event.client_payload.repository }}

    - name: Create a check on public
      id: public-check
      if: ${{ github.event_name == 'repository_dispatch' }}
      uses: LouisBrunner/checks-action@v1.1.1
      with:
        token: ${{ steps.app-token.outputs.token }}
        repo: ${{ github.event.client_payload.repository }}
        sha: ${{ github.event.client_payload.head_sha }}
        name: ${{ github.job }}
        status: in_progress
        details_url: ${{ env.RUN_URL }}

    - name: Retrieve the repository
      uses: actions/download-artifact@v2
      with:
        name: ${{ env.HEAD_REF }}.git
        path: .git

    - name: Enable symlinks
      run: git config --local core.symlinks true

    - name: Check out the code
      # See the same step in the macOS job for why this can't be abstracted into our `checkout` action.
      run: |
        # Authenticate with the new token.
        git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $( [Convert]::ToBase64String([System.Text.Encoding]::Ascii.GetBytes('x-access-token:${{ secrets.GITHUB_TOKEN }}')) )"
        git checkout --progress --force ${{ env.HEAD_REF }}

    - name: Check out submodules and fetch tags
      uses: ./.github/actions/checkout

    - name: Determine build parameters
      id: build-params
      uses: ./.github/actions/build-params

    - name: Install Qt
      uses: jurplel/install-qt-action@v2
      with:
        mirror: http://mirrors.ocf.berkeley.edu/qt/
      timeout-minutes: 10

    - name: Install Dependencies from Choco
      uses: crazy-max/ghaction-chocolatey@v1
      with:
        args: install --yes qemu-img openssl

    - name: Download YASM
      uses: carlosperate/download-file-action@v1.0.3
      with:
        file-url: https://www.tortall.net/projects/yasm/releases/yasm-1.3.0-win64.exe
        file-name: yasm.exe
        location: ${{ github.workspace }}/../

    - name: Set up MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Build
      uses: lukka/run-cmake@v2
      env:
        ASM_NASM: "${{ github.workspace }}\\..\\yasm.exe"
      with:
        cmakeListsOrSettingsJson: CMakeListsTxtAdvanced
        buildDirectory: ${{ env.BUILD_DIR }}
        cmakeAppendedArgs:
          -GNinja
          -DCMAKE_BUILD_TYPE=RelWithDebInfo
          -DCMAKE_C_COMPILER=cl.exe
          -DCMAKE_CXX_COMPILER=cl.exe
          -DMULTIPASS_UPSTREAM=origin
          -DMULTIPASS_BUILD_LABEL=${{ steps.build-params.outputs.label }}

    - name: Test
      working-directory: ${{ env.BUILD_DIR }}
      run: |
        bin/multipass_tests.exe

    - name: Package
      id: cmake-package
      working-directory: ${{ env.BUILD_DIR }}
      run: |
        cmake --build . --target package
        echo "::set-output name=name::$( ( Get-ChildItem multipass-*.exe ).Name )"
        echo "::set-output name=path::$( ( Get-ChildItem multipass-*.exe ).FullName )"

    - name: Get NSIS logs
      if: ${{ failure() && steps.cmake-package.outcome == 'failure' }}
      run: cat ${{ env.BUILD_DIR }}/_CPack_Packages/win64/NSIS/NSISOutput.log

    - name: Upload package
      uses: actions/upload-artifact@v2
      with:
        name: ${{ steps.cmake-package.outputs.name }}
        path: ${{ steps.cmake-package.outputs.path }}
        if-no-files-found: error

    - name: Update the check on public
      if: ${{ always() && github.event_name == 'repository_dispatch' }}
      uses: LouisBrunner/checks-action@v1.1.1
      with:
        token: ${{ steps.app-token.outputs.token }}
        repo: ${{ github.event.client_payload.repository }}
        sha: ${{ github.event.client_payload.head_sha }}
        check_id: ${{ steps.public-check.outputs.check_id }}
        conclusion: ${{ job.status }}
